#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Feb 11

@author: J Baker, E Castelli,
"""

import numpy as np
import copy
from pytdi.michelson import X1, Y1, Z1, X2, Y2, Z2
from .data import TimeData
from.filter import LinearFilter

class DeducedTDIFilter(LinearFilter):
    '''
    This class realizes a constant LinearFilter based on a deduced TDI stencil.  

    The stencil is computed from a measurements data file as generated by LISAInstrument. Information in that file is used with pytdi to compute reverse engineer the defacto TDI operation applied at a reference point in the data stream.  The output channels are TDI2 X, Y and Z.
    '''

    def __init__(self, measurements_data,i0=300,nleft=300,nright=500):
        '''
        Base constructor for LinearFilter.

        This base class addresses only the functionality for linear filtering 
        itself, not any specifics of filter design and development.  It 
        implements a trivial identity filter.

        Parameters
        ----------
        nhalf : int
            The halfwidth of the applied filter stencil. The output of filtering
            will be shorter than the input series by nhalf samples on each end.
        n_input_channels: int
            The number of channels that the data is expected to be applied to.
        input_names: list
            If provided, the channels of the data provided for filtering can 
            be checked against these names.
        
        Interface data:
            Each of nhalf, n_channels and input_names are stored internally.
            We also generally store the following:
            
            output_names: list or None
                Names of the output channels provided with outptu data.
            dt: float
                In/out data sample rate, verified on filtering and provided
                with filter output data.
            stencil_compts: ndarray
                The components of the convolution stencil realizing the filter.
                To be referenced only internally or supplanted by derived class
                Must be set by derived class if the default apply_filter is
                to work. 
                Shape must be (n_output_channels, 1+2*nhalf, n_input_channels)
            constant_stencil: bool 
                If True then no time info is needed to apply the filter 
                otherwise this but be incorporated in the input_data TimeData 
                object. Must be true for default apply_filter.
        '''
        
        ioff,stencil = DeducedTDIFilter.compute_stencil_from_measurements(measurements_data,i0=i0,nleft=nleft,nright=nright)
        self.nleft = ioff
        self.nright=len(stencil[0,0])
        self.n_input_channels=6
        self.input_names=None
        self.n_output_channels=3
        self.stencil_compts=np.transpose(stencil,[0,2,1])
        self.constant_stencil=True
    
    def compute_stencil_from_measurements(measurements,i0,nleft,nright):
        '''
        Deduce the TDI stencil.

        Beginning with a measurements data object as comes from TDI instrument. This function uses pytdi to
        apply the TDI2 algorithm for zero-response and impulse response to deduce a convolution stencil operator
        which realizes the TDI application. It is hoped that this reverse-engineered approach is less exposed to
        any convention or other version-evolution changes, as it identifies the calculation as it is realized
        rather than as it is believed to be designed.

        Parameters
        ----------
        measurements : pytdi.Data
                       TDI data object, includes all the information needed to apply TDI to single-link data.
                   i0: int
                       Input data sample index value at which to derive the TDI stencil
                nleft: int    
                       How many samples to the left to include in the search for impulse response
               nright: int
                       How many samples to the right to include.

        Returns
        ----------
        (ioff, stencil)
               ioff: int
                     Offset from the impulse response of the first stencil-response element
            stencil: ndarray
                     This is the set of convolution stencils shaped as (nTDI, nLink, nstencil)
                     The TDI channels are orders ['X', 'Y', 'Z']
                     The input links are ordered ['12', '23', '31', '13', '21', '32']                                 
        '''
        
        assert i0-nleft>=0, "out of range"
        mosas_order = ['12', '23', '31', '13', '21', '32']  ##Is there a way to get this from pytdi?

        #make modified version of the measurements data args
        newargs=copy.deepcopy(measurements.args)
        for k in newargs['delays'].keys():
            #print(k,newargs['delays'][k].shape,newargs['delay_derivatives'][k].shape)
            newargs['delays'][k]=newargs['delays'][k][i0-nleft:i0+nright]
            newargs['delay_derivatives'][k]=newargs['delay_derivatives'][k][i0-nleft:i0+nright]
        XYZ_ops=[chan.build(**newargs) for chan in [X2,Y2,Z2]]
        #display(newargs)

        #Compute the zero-response for the relevant stretch of data
        measurements_z=copy.deepcopy(measurements.measurements)
        for k in measurements_z.keys():
            #print(k,measurements[k].shape)
            measurements_z[k]=measurements_z[k][i0-nleft:i0+nright]

        for link in mosas_order:
            name=f'isi_{link}'
            data=np.zeros((nleft+nright,))
            measurements_z[name]=data
        #print('computing TDI')
        XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])
        #print(XYZ_z)

        #now get the single-point-impulse-responses
        XYZ_1={}
        minmaxs=[]
        for link in mosas_order:
            #print(link)
            measurements_1=copy.deepcopy(measurements_z)
            name=f'isi_{link}'
            #print(name,data.shape,'\n',data)
            measurements_1[name][nleft]=1
            XYZ_z=np.array([op(measurements_1) for op in XYZ_ops])
            XYZ_1[link]=np.array([op(measurements_z) for op in XYZ_ops])-XYZ_z
            for i in range(3):
                nz=np.nonzero(XYZ_1[link][i])[0]
                minmax = [min(nz),max(nz)] if len(nz)>0 else ''
                #print(link,'XYZ'[i],len(nz),minmax)
                if len(nz)>0:minmaxs+=[minmax]
        #display(XYZ_1)
        first=min([minmax[0] for minmax in minmaxs])
        last=max([minmax[1] for minmax in minmaxs])
        length=last+1-first
        #print('length,first,last',length,first,last)

        stencil=np.zeros((3,6,length))
        for ilink in range(len(mosas_order)):
            link=mosas_order[ilink]
            for i in range(3):
                stencil[:,ilink,:]=XYZ_1[link][:,first:last+1]
            #print('shape change:',XYZ_1[link].shape,stencil[link].shape)
        ioff=nleft-first
        #print('ioff',ioff)
        #display(stencil)
        return ioff, stencil    



        
        
            

        
        

        
