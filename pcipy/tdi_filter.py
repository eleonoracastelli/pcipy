#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Feb 11

@author: J Baker, E Castelli,
"""

import numpy as np
import copy
from pytdi.michelson import X1, Y1, Z1, X2, Y2, Z2
from .data import TimeData
from.filter import LinearFilter

class DeducedTDIFilter(LinearFilter):
    '''
    This class realizes a constant LinearFilter based on a deduced TDI kernel.  

    The kernel is computed from a measurements data file as generated by LISAInstrument. Information in that file is used with pytdi to compute reverse engineer the defacto TDI operation applied at a reference point in the data stream.  The output channels are TDI2 X, Y and Z.
    '''

    def __init__(self, measurements_data,eval_time=None,nleft=300,nright=500,in_chans=['isi'],method="simple"):
        '''
        This class realizes a constant LinearFilter based on a deduced TDI stencil.  

        The stencil is computed from a measurements data file as generated by LISAInstrument. 
        Information in that file is used with pytdi to compute reverse engineer the defacto TDI 
        operation applied at a reference point in the data stream.  The output channels are TDI2 
        X, Y and Z.

        Parameters
        ----------
        measurements_data: pytdi.Data
            This should be a Data structure from pytdi for instrument simulation data
        eval_time: float
            This is the time point in the (output) data stream for which the TDI kernel should
            be estimated. By default, t0=None, and t0 is set to the earliest point which is 
            supported.
        nleft: int
            The number of points that TDI response should be searched for to the left of the
            input-stream point.
        nright: int
            The number of points that TDI response should be searched for to the right of the
            input-stream point.
        in_chans: list
            This is the list of which pytdi data channel types to include in the TDI kernel computation.
            The default is ['isi'] which uses only the inter-spacecraft interferometer. To use all
            18 central phasemeter channels set to ['isi','rfi','tmi'].
        method: string
            This determines the method for estimating the TDI kernel. Default is 'simple' which
            estimates via pytdi impluse response, ignoring the small amount of variation in the
            response across the kernel width.  The 'exact' treatment is quite slow (minutes) but
            computes the impulse response exactly for each kernel coefficient.  The compromise
            'linear' treatment computes the the exact impulse response at the times corresponding
            to the kernel start and end, but linearly interpolates the interior coefficients.  
            Each method begins with the simple treatment to determine the kernel extent. 
        '''

        self.in_chans=in_chans
        self.mosas_order = ['12', '23', '31', '13', '21', '32']
        in_names=[]
        for chan in in_chans:
            for link in self.mosas_order:
                in_names.append(f'{chan}_{link}')
        self.in_names=in_names
        self.input_names=None
        
        self.dt=1/measurements_data.fs
        self.t0=None
        if eval_time is None:
            i0 = nleft
        else:
            i0 = int(eval_time/self.dt+0.5)

        ioff,kernel = DeducedTDIFilter.compute_kernel_from_measurements(in_names,measurements_data,i0=i0,nleft=nleft,nright=nright,method=method)
        self.nright = ioff
        self.nleft=len(kernel[0]) - 1 - ioff
        
        # In this case, because the above compute_kernel_from_measurements function takes input
        # data from i0, which is applied to produce output TDI data ranging from i0-nleft to i0+nright,
        # we take the middle point of that range as the time-reference point.  TBD is to modify
        # the compute_kernel function to be fully consistent with output at i0 in the output stream.
        # Then we should also ensure that kernel_ref_time= t0
        self.kernel_ref_time =  ( i0 - ( self.nright - self.nleft ) // 2 ) * self.dt 
        self.n_input_channels=len(in_names)
        self.n_output_channels=3
        self.kernel_compts=kernel#np.transpose(kernel,[0,2,1])
        #print('Constructed TDI kernel of shape',self.kernel_compts.shape,' and set nleft and nright to:',self.nleft, self.nright)
        self.constant_kernel=True

        self.output_names=['X','Y','Z']
        
    def compute_kernel_from_measurements(input_names,measurements,i0,nleft,nright,method):
        '''
        Deduce the TDI kernel.

        Beginning with a measurements data object as comes from TDI instrument. This function uses pytdi to
        apply the TDI2 algorithm for zero-response and impulse response to deduce a convolution kernel operator
        which realizes the TDI application. It is hoped that this reverse-engineered approach is less exposed to
        any convention or other version-evolution changes, as it identifies the calculation as it is realized
        rather than as it is believed to be designed.  The precise approach to the reverse-engineering depends
        on the value of the method argument.

        Parameters
        ----------
        intput_names : list of string
                       The list includes the names of all the pytdi.Data channels to apply as inputs.
        measurements : pytdi.Data
                       TDI data object, includes all the information needed to apply TDI to single-link data.
                   i0: int
                       Input data sample index value at which to derive the TDI kernel
                nleft: int    
                       How many samples to the left to include in the search for impulse response
               nright: int
                       How many samples to the right to include.
               method: string
                       This determines the method for estimating the TDI kernel. Default is 'simple' which
                       estimates via pytdi impluse response, ignoring the small amount of variation in the
                       response across the kernel width.  The 'exact' treatment is quite slow (minutes) but
                       computes the impulse response exactly for each kernel coefficient.  The compromise
                       'linear' treatment computes the the exact impulse response at the times corresponding
                       to the kernel start and end, but linearly interpolates the interior coefficients.  
                       Each method begins with the simple treatment to determine the kernel extent. 

        Returns
        ----------
        (ioff, kernel)
               ioff: int
                     Offset from the impulse response of the first kernel-response element
            kernel: ndarray
                     This is the set of convolution kernels shaped as (nTDI, nLink, nkernel)
                     The TDI channels are orders ['X', 'Y', 'Z']
                     The input links are ordered ['12', '23', '31', '13', '21', '32']                                 
        '''
        
        ioff, kernel = DeducedTDIFilter.compute_kernel_from_measurements_simple(input_names,measurements,i0=i0,nleft=nleft,nright=nright)
        if method=='simple':
            pass
        elif method=='exact':
            assert ioff==0, "'exact' kernel computation does not support ioff!-0"
            kernel =  DeducedTDIFilter.compute_kernel_from_measurements_exact(input_names,measurements,i0=0,pastwidth=len(kernel),buffer=0)
        elif method=='linear':
            assert ioff==0, "'linear' kernel computation does not support ioff!-0"
            kernel =  DeducedTDIFilter.compute_kernel_from_measurements_linear(input_names,measurements,i0=0,pastwidth=len(kernel),buffer=0)
        else:
            raise ValueError("method '"+method+"' not recognized.")

        return ioff, kernel
    
    def compute_kernel_from_measurements_simple(input_names,measurements,i0,nleft,nright):
        '''
        Deduce the TDI kernel using the simple method.

        Beginning with a measurements data object as comes from TDI instrument. This function uses pytdi to
        apply the TDI2 algorithm for zero-response and impulse response to deduce a convolution kernel operator
        which realizes the TDI application. This simple forward modeling treatment is not exact because the
        kernel we need must apply exactly when i0 is the output evaulation time.  This method takes i0 as the
        input channel time and computes the coefficients connecting those samples to the output across a range
        of times.  It is inexact if the kernel is time-dependent and varies across a time as small as its width.

        Parameters
        ----------
        intput_names : list of string
                       The list includes the names of all the pytdi.Data channels to apply as inputs.
        measurements : pytdi.Data
                       TDI data object, includes all the information needed to apply TDI to single-link data.
                   i0: int
                       Input data sample index value at which to derive the TDI kernel
                nleft: int    
                       How many samples to the left to include in the search for impulse response
               nright: int
                       How many samples to the right to include.

        Returns
        ----------
        (ioff, kernel)
               ioff: int
                     Offset from the impulse response of the first kernel-response element
            kernel: ndarray
                     This is the set of convolution kernels shaped as (nTDI, nLink, nkernel)
                     The TDI channels are orders ['X', 'Y', 'Z']
                     The input links are ordered ['12', '23', '31', '13', '21', '32']                                 
        '''
        
        assert i0-nleft>=0, "out of range"

        #make modified version of the measurements data args
        newargs=copy.deepcopy(measurements.args)
        for k in newargs['delays'].keys():
            #print(k,newargs['delays'][k].shape,newargs['delay_derivatives'][k].shape)
            newargs['delays'][k]=newargs['delays'][k][i0-nleft:i0+nright]
            newargs['delay_derivatives'][k]=newargs['delay_derivatives'][k][i0-nleft:i0+nright]
        XYZ_ops=[chan.build(**newargs) for chan in [X2,Y2,Z2]]
        #display(newargs)

        #Compute the zero-response for the relevant stretch of data
        measurements_z=copy.deepcopy(measurements.measurements)
        for k in measurements_z.keys():
            #print(k,measurements[k].shape)
            measurements_z[k]=measurements_z[k][i0-nleft:i0+nright]

        for name in input_names:
            data=np.zeros((nleft+nright,))
            measurements_z[name]=data
        #print('computing TDI')
        XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])
        #print(XYZ_z)

        #now get the single-point-impulse-responses
        XYZ_1={}
        minmaxs=[]
        for name in input_names:
            #print(link)
            measurements_1=copy.deepcopy(measurements_z)
            #print(name,data.shape,'\n',data)
            measurements_1[name][nleft]=1
            XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])
            XYZ_1[name]=np.array([op(measurements_1) for op in XYZ_ops])-XYZ_z
            for i in range(3):
                nz=np.nonzero(XYZ_1[name][i])[0]
                minmax = [min(nz),max(nz)] if len(nz)>0 else ''
                #print(link,'XYZ'[i],len(nz),minmax)
                if len(nz)>0:minmaxs+=[minmax]
        #display(XYZ_1)
        first=min([minmax[0] for minmax in minmaxs])
        last=max([minmax[1] for minmax in minmaxs])
        length=last+1-first
        #print('length,first,last',length,first,last)

        kernel=np.zeros((3,length,len(input_names)))
        for ilink in range(len(input_names)):
            name=input_names[ilink]
            for i in range(3):
                kernel[:,:,ilink]=XYZ_1[name][:,first:last+1]
            #print('shape change:',XYZ_1[link].shape,kernel[link].shape)
        ioff=nleft-first
        #print('ioff',ioff)
        #display(kernel)
        return ioff, kernel[:,::-1,:]    


    ###Now we reorganize pack that all into a neat bundle
    def compute_kernel_from_measurements_exact(input_names, noise_data,i0=0,pastwidth=300,buffer=0):
        '''        
        This version applies input impulse response across with impulses across the full width of the kernel 
        but response only taken from the i0 point.
        It may be somewhat slow, so that an approximation might be considered...TBD
        For simplicity, we only treat the case where the kernel is strictly non-future-supported 
        
        pastwidth should be the full width of the (past-dominated) kernel which also includes i0
        buffer is extra width on each side to include in the impulse response calculation
        '''

        # 1. First we restrict to a relevant stretch of data
        istart=i0-(pastwidth-1)-buffer
        iend=i0+buffer+pastwidth #We add pastwidth to ensure that there is room for the forward kernel from i0
        assert istart>=0, "out of range at start"

        #make modified version of the data_noise args
        newargs=copy.deepcopy(noise_data.args)
        for k in newargs['delays'].keys():
            #print(k,newargs['delays'][k].shape,newargs['delay_derivatives'][k].shape)
            newargs['delays'][k]=newargs['delays'][k][istart:iend]
            newargs['delay_derivatives'][k]=newargs['delay_derivatives'][k][istart:iend]
        XYZ_ops=[chan.build(**newargs) for chan in [X2,Y2,Z2]]
        #display(newargs)

        #Compute the zero-response for the relevant stretch of data
        measurements_z=copy.deepcopy(noise_data.measurements)
        for k in measurements_z.keys():
            #print(k,measurements[k].shape)
            measurements_z[k]=measurements_z[k][istart:iend]

        names=input_names    
        nchan_in=len(names)

        for name in names:
            data=np.zeros((iend-istart,))
            measurements_z[name]=data
        #print('computing TDI')
        XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])
        #print(XYZ_z)

        # 2. Get the zero-response
        XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])[:,i0-istart]

        # 3. Now get the single-point-impulse-responses to populate the kernel
        kernel = np.zeros((3,pastwidth,nchan_in))
        for ilink in range(nchan_in):
            name=names[ilink]
            print(name)
            for j in range(pastwidth): #loop over points in the kernel
                measurements_1=copy.deepcopy(measurements_z)
                #name=f'isi_{link}'
                measurements_1[name][i0-j-istart]=1
                kernel[:,pastwidth-j-1,ilink]=np.array([op(measurements_1) for op in XYZ_ops])[:,i0-istart]-XYZ_z

        return kernel

        ###Now we reorganize pack that all into a neat bundle
        def compute_kernel_from_measurements_linear(input_names, noise_data,i0=0,pastwidth=300,buffer=20):
            '''
            This version applies input impulse response across with impulses at each end of the kernel spanning
            the pastwidth and linearly interpolates inbetween.

            pastwidth should be the full width of the (past-dominated) kernel which also includes i0
            buffer is extra width on each side to include in the impulse response calculation
            '''

            # 1. First we restrict to a relevant stretch of data
            istart=i0-(pastwidth-1)-buffer
            iend=i0+buffer+pastwidth #We add pastwidth to ensure that there is room for the forward kernel from i0
            assert istart>=0, "out of range at start"

            #make modified version of the data_noise args
            newargs=copy.deepcopy(noise_data.args)
            for k in newargs['delays'].keys():
                #print(k,newargs['delays'][k].shape,newargs['delay_derivatives'][k].shape)
                newargs['delays'][k]=newargs['delays'][k][istart:iend]
                newargs['delay_derivatives'][k]=newargs['delay_derivatives'][k][istart:iend]
            XYZ_ops=[chan.build(**newargs) for chan in [X2,Y2,Z2]]
            #display(newargs)

            #Compute the zero-response for the relevant stretch of data
            measurements_z=copy.deepcopy(noise_data.measurements)
            for k in measurements_z.keys():
                #print(k,measurements[k].shape)
                measurements_z[k]=measurements_z[k][istart:iend]

            names=input_names
            nchan_in=len(names)

            for name in names:
                data=np.zeros((iend-istart,))
                measurements_z[name]=data
            #print('computing TDI')
            XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])
            #print(XYZ_z)

            # 2. Get the zero-response
            XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])

            # 3. Now get the full set of responses for the endpoints of the kernel
            samp_points=np.array([0,pastwidth-1])
            samp_coeffs = np.zeros((2,3,pastwidth,nchan_in))
            for isamp in range(2):
                jsamp=samp_points[isamp]
                for ilink in range(nchan_in):
                    name=names[ilink]
                    print(name)
                    measurements_1=copy.deepcopy(measurements_z)
                    iimpulse=i0-istart-jsamp
                    measurements_1[name][iimpulse]=1
                    samp_coeffs[isamp,:,:,ilink]=np.array([op(measurements_1) for op in XYZ_ops])[:,iimpulse:iimpulse+pastwidth]-XYZ_z[:,iimpulse:iimpulse+pastwidth]

            # 4. Now interpolate
            so=samp_coeffs[0]
            print('sc0 max',np.max(so),np.unravel_index(so.argmax(), so.shape))
            print('sc0 min',np.min(so),np.unravel_index(so.argmin(), so.shape))
            so=samp_coeffs[1]
            print('sc1 max',np.max(so),np.unravel_index(so.argmax(), so.shape))
            print('sc1 min',np.min(so),np.unravel_index(so.argmin(), so.shape))
            print(samp_coeffs[0])

            print('sc0,sc1 (pretranspose) at [1,249,0]',samp_coeffs[0][1,249,0],samp_coeffs[1][1,249,0])
            samp_coeffs=samp_coeffs.transpose(0,1,3,2)
            ioff=list(range(pastwidth))
            eps = (ioff-samp_points[0])/(samp_points[1]-samp_points[0])
            print(eps)
            kernel=samp_coeffs[0]*(1-eps)+samp_coeffs[1]*eps
            print('sc0,sc1,k at [1,0,249]',samp_coeffs[0][1,0,249],samp_coeffs[1][1,0,249],kernel[1,0,249])
            kernel=kernel.transpose(0,2,1)[:,::-1,:]

            return kernel#,samp_coeffs.transpose(0,1,3,2)




        
        
            

        
        

        
