#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Feb 11

@author: J Baker, E Castelli,
"""

import numpy as np
import copy
from pytdi.michelson import X1, Y1, Z1, X2, Y2, Z2
from .data import TimeData
from.filter import LinearFilter

class DeducedTDIFilter(LinearFilter):
    '''
    This class realizes a constant LinearFilter based on a deduced TDI stencil.  

    The stencil is computed from a measurements data file as generated by LISAInstrument. Information in that file is used with pytdi to compute reverse engineer the defacto TDI operation applied at a reference point in the data stream.  The output channels are TDI2 X, Y and Z.
    '''

    def __init__(self, measurements_data,eval_time=None,nleft=300,nright=500):
        '''
        This class realizes a constant LinearFilter based on a deduced TDI stencil.  

        The stencil is computed from a measurements data file as generated by LISAInstrument. 
        Information in that file is used with pytdi to compute reverse engineer the defacto TDI 
        operation applied at a reference point in the data stream.  The output channels are TDI2 
        X, Y and Z.

        Parameters
        ----------
        measurements_data: pytdi.Data
            This should be a Data structure from pytdi for instrument simulation data
        eval_time: float
            This is the time point in the (output) data stream for which the TDI stencil should
            be estimated. By default, t0=None, and t0 is set to the earliest point which is 
            supported.
        nleft: int
            The number of points that TDI response should be searched for to the left of the
            input-stream point.
        nright: int
            The number of points that TDI response should be searched for to the right of the
            input-stream point.
        '''

        self.dt=1/measurements_data.fs
        self.t0=None
        if eval_time is None:
            i0 = nleft
        else:
            i0 = int(eval_time/self.dt+0.5)
        ioff,stencil = DeducedTDIFilter.compute_stencil_from_measurements(measurements_data,i0=i0,nleft=nleft,nright=nright)
        self.nright = ioff
        self.nleft=len(stencil[0]) - 1 - ioff
        # In this case, because the above compute_stencil_from_measurements function takes input
        # data from i0, which is applied to produce output TDI data ranging from i0-nleft to i0+nright,
        # we take the middle point of that range as the time-reference point.  TBD is to modify
        # the compute_stencil function to be fully consistent with output at i0 in the output stream.
        # Then we should also ensure that stencil_ref_time= t0
        self.stencil_ref_time =  ( i0 - ( self.nright - self.nleft ) // 2 ) * self.dt 
        self.n_input_channels=6
        self.input_names=None
        self.n_output_channels=3
        self.stencil_compts=stencil#np.transpose(stencil,[0,2,1])
        #print('Constructed TDI stencil of shape',self.stencil_compts.shape,' and set nleft and nright to:',self.nleft, self.nright)
        self.constant_stencil=True

        self.output_names=['X','Y','Z']
        
    def compute_stencil_from_measurements(measurements,i0,nleft,nright):
        '''
        Deduce the TDI stencil.

        Beginning with a measurements data object as comes from TDI instrument. This function uses pytdi to
        apply the TDI2 algorithm for zero-response and impulse response to deduce a convolution stencil operator
        which realizes the TDI application. It is hoped that this reverse-engineered approach is less exposed to
        any convention or other version-evolution changes, as it identifies the calculation as it is realized
        rather than as it is believed to be designed.

        Parameters
        ----------
        measurements : pytdi.Data
                       TDI data object, includes all the information needed to apply TDI to single-link data.
                   i0: int
                       Input data sample index value at which to derive the TDI stencil
                nleft: int    
                       How many samples to the left to include in the search for impulse response
               nright: int
                       How many samples to the right to include.

        Returns
        ----------
        (ioff, stencil)
               ioff: int
                     Offset from the impulse response of the first stencil-response element
            stencil: ndarray
                     This is the set of convolution stencils shaped as (nTDI, nLink, nstencil)
                     The TDI channels are orders ['X', 'Y', 'Z']
                     The input links are ordered ['12', '23', '31', '13', '21', '32']                                 
        '''
        
        assert i0-nleft>=0, "out of range"
        mosas_order = ['12', '23', '31', '13', '21', '32']  ##Is there a way to get this from pytdi?

        #make modified version of the measurements data args
        newargs=copy.deepcopy(measurements.args)
        for k in newargs['delays'].keys():
            #print(k,newargs['delays'][k].shape,newargs['delay_derivatives'][k].shape)
            newargs['delays'][k]=newargs['delays'][k][i0-nleft:i0+nright]
            newargs['delay_derivatives'][k]=newargs['delay_derivatives'][k][i0-nleft:i0+nright]
        XYZ_ops=[chan.build(**newargs) for chan in [X2,Y2,Z2]]
        #display(newargs)

        #Compute the zero-response for the relevant stretch of data
        measurements_z=copy.deepcopy(measurements.measurements)
        for k in measurements_z.keys():
            #print(k,measurements[k].shape)
            measurements_z[k]=measurements_z[k][i0-nleft:i0+nright]

        for link in mosas_order:
            name=f'isi_{link}'
            data=np.zeros((nleft+nright,))
            measurements_z[name]=data
        #print('computing TDI')
        XYZ_z=np.array([op(measurements_z) for op in XYZ_ops])
        #print(XYZ_z)

        #now get the single-point-impulse-responses
        XYZ_1={}
        minmaxs=[]
        for link in mosas_order:
            #print(link)
            measurements_1=copy.deepcopy(measurements_z)
            name=f'isi_{link}'
            #print(name,data.shape,'\n',data)
            measurements_1[name][nleft]=1
            XYZ_z=np.array([op(measurements_1) for op in XYZ_ops])
            XYZ_1[link]=np.array([op(measurements_z) for op in XYZ_ops])-XYZ_z
            for i in range(3):
                nz=np.nonzero(XYZ_1[link][i])[0]
                minmax = [min(nz),max(nz)] if len(nz)>0 else ''
                #print(link,'XYZ'[i],len(nz),minmax)
                if len(nz)>0:minmaxs+=[minmax]
        #display(XYZ_1)
        first=min([minmax[0] for minmax in minmaxs])
        last=max([minmax[1] for minmax in minmaxs])
        length=last+1-first
        #print('length,first,last',length,first,last)

        stencil=np.zeros((3,length,6))
        for ilink in range(len(mosas_order)):
            link=mosas_order[ilink]
            for i in range(3):
                stencil[:,:,ilink]=XYZ_1[link][:,first:last+1]
            #print('shape change:',XYZ_1[link].shape,stencil[link].shape)
        ioff=nleft-first
        #print('ioff',ioff)
        #display(stencil)
        return ioff, stencil[:,::-1,:]    



        
        
            

        
        

        
